/*
 * scheduler.c
 *
 *  Created on: Nov 24, 2022
 *      Author: HELLO SON
 */
#include "scheduler.h"
sTask SCH_TASKS_G[SCH_MAX_TASKS];
void SCH_DELETE_TASK(unsigned char index)
{
	if(SCH_TASKS_G[index].pTask==0)
	{
		return;
	}
	else{
		SCH_TASKS_G[index].pTask=0x0000;
		SCH_TASKS_G[index].Runme=0;
		SCH_TASKS_G[index].Period=0;
		SCH_TASKS_G[index].Delay=0;
	}

}
void SCH_Update(void)
{
	unsigned char index;
	for(index=0;index<SCH_MAX_TASKS;index++)
	{
		if(SCH_TASKS_G[index].pTask)
		{
			if(SCH_TASKS_G[index].Delay==0)
			{
				SCH_TASKS_G[index].Runme+=1;
				if(SCH_TASKS_G[index].Period)
				{
					SCH_TASKS_G[index].Delay=SCH_TASKS_G[index].Period;
				}
			}
			else
			{
				SCH_TASKS_G[index].Delay-=1;
			}

		}
	}
}
void SCH_Add_Tasks(void (*pFunction)(),uint32_t DELAY, uint32_t PERIOD)
{
	unsigned char index;
	while((SCH_TASKS_G[index].pTask!=0) && (index<SCH_MAX_TASKS))
	{
		index++;
	}
	if(index==SCH_MAX_TASKS)
	{
		return;
	}
	SCH_TASKS_G[index].pTask=pFunction;
	SCH_TASKS_G[index].Delay=DELAY;
	SCH_TASKS_G[index].Period=PERIOD;
	SCH_TASKS_G[index].Runme=0;
}
void SCH_Dispatch_Tasks(void)
{
	unsigned char index;
	for(index=0;index<SCH_MAX_TASKS;index++)
	{
		if(SCH_TASKS_G[index].Runme>0)
		{
			(*SCH_TASKS_G[index].pTask)();
			SCH_TASKS_G[index].Runme-=1;
			if(SCH_TASKS_G[index].Period==0)
			{
				SCH_DELETE_TASK(index);
			}

		}
	}
}
void SCH_INIT(void)
{
	unsigned char i;
	for(i=0;i<SCH_MAX_TASKS;i++)
	{
		SCH_DELETE_TASK(i);
	}
}
